window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "fpex0", "modulename": "fpex0", "type": "module", "doc": "<h1 id=\"fpex0-python\">FPEX0 Python</h1>\n\n<p>This package gives a Python implementation of the FPEX0 method <br />\nfor data-driven de-smearing of DSC signals presented in the paper</p>\n\n<p>Sommer, Andreas; Hohenauer, Wolfgang; Barz, Tilman: <br />\nData-driven de-smearing of DSC signals.\nJ Therm Anal Calorim (2022).\n<a href=\"https://doi.org/10.1007/s10973-022-11258-y\">https://doi.org/10.1007/s10973-022-11258-y</a></p>\n\n<p>A Matlab version of FPEX0 is available at\n<a href=\"https://github.com/andreassommer/fpex0\">https://github.com/andreassommer/fpex0</a></p>\n\n<h2 id=\"installing-the-package\">Installing the package</h2>\n\n<p>The fpex0 package can be installed via pip:</p>\n\n<pre><code>pip install fpex0\n</code></pre>\n\n<h2 id=\"running-an-example\">Running an example</h2>\n\n<p>The software comes with an example implemented in fpex0.example.exampleFit().\nRunning it will import example measurements, build an example setup and execute the algorithm. <br />\nAfter about 20 steps it should give a solution near by:</p>\n\n<blockquote>\n<pre><code>  p = [-0.9562, 0.0329, 0.2760, 3.4708, 2.5866, 42.5333, 131.8052, 3.7384, 0.1879]\n</code></pre>\n</blockquote>\n\n<h2 id=\"extrapolating-your-own-data\">Extrapolating your own data</h2>\n\n<p>The heart of the package are the function fpex0.fit() and the class fpex0.Setup.\nSetup holds your measurements and all problem-related configurations, e.g. your diffusion function and its\ninital parameters. Then fit() uses your setup to fit the Fokker-Planck evolution to your measurements as\nan optimization problem.\nThe example fit and used example functions should give a good understanding how the software is used.\nPlease also read about sympy symbolic functions if not familiar.</p>\n\n<h2 id=\"data-processing\">Data processing</h2>\n\n<p>The functions described above assume <strong>baseline corrected</strong> data, so raw measurements must be processed.\nThe modules CP, baseline can do that for you. <br>\nThe processing consists of two parts: (1) calculating heat capacities, (2) detecting a baseline and\nsubtracting it. \nBoth of it is done by addCP() plus some previous data preparation. As there is no code example, we\nexplain its usage:</p>\n\n<ol>\n<li>Create a DSC_Data object and load measurements</li>\n</ol>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">dsc_data</span> <span class=\"o\">=</span> <span class=\"n\">DSC_Data</span><span class=\"p\">()</span>\n<span class=\"n\">dsc_data</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">=</span> <span class=\"n\">T</span>\n<span class=\"n\">dsc_data</span><span class=\"o\">.</span><span class=\"n\">dsc</span> <span class=\"o\">=</span> <span class=\"n\">dsc</span>\n<span class=\"n\">dsc_data</span><span class=\"o\">.</span><span class=\"n\">rate</span> <span class=\"o\">=</span> <span class=\"n\">rate</span>\n</code></pre>\n</div>\n\n<ol>\n<li>Process</li>\n</ol>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">dsc_data</span> <span class=\"o\">=</span> <span class=\"n\">addCP</span><span class=\"p\">(</span><span class=\"n\">dsc_data</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<ol>\n<li>Create fpex0 setup and import your data</li>\n</ol>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">FPEX0setup</span> <span class=\"o\">=</span> <span class=\"n\">Setup</span><span class=\"p\">(</span><span class=\"n\">gridObj</span><span class=\"p\">,</span> <span class=\"n\">parametersObj</span><span class=\"p\">,</span> <span class=\"n\">integrationObj</span><span class=\"p\">,</span> <span class=\"n\">FPdriftFcn</span><span class=\"p\">,</span> <span class=\"n\">FPdiffusionFcn</span><span class=\"p\">,</span> <span class=\"n\">IniDistFcn</span><span class=\"p\">)</span>\n<span class=\"n\">FPEX0setup</span><span class=\"o\">.</span><span class=\"n\">importDSCobj</span><span class=\"p\">(</span><span class=\"n\">dsc_data</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Now you can modify the setup and extrapolate your data.</p>\n\n<p>If you want to skip part (1) or (2), check for CP_DIN11357(), getBaseline(), subtractBaseline() or the\nsource code of addCP().</p>\n\n<h2 id=\"about-the-implementation\">About the implementation</h2>\n\n<p>This is a Python version of Andreas Sommer's matlab implementation, which can be found at\n<a href=\"https://github.com/andreassommer/fpex0\">https://github.com/andreassommer/fpex0</a>.</p>\n\n<p>The Fokker-Planck equation is solved as an ODE via method of lines, using scipy\nsolve_ivp with BDF method as a default. That is basically a python version of matlab ode15s. <br />\nThe initial distribution, drift and diffusion are then fitted to the measurement data via an optimizer,\nby default scipy least_squares (which is also currently the only option). <br />\nOther optimizers and integrators can be implemented by the user, if compatible to the interplay of\nfpex0.fit(), residual() and simulate(). However, the software is designed around the method of lines,\nso using another method to solve Fokker-Planck will require significant adjustments.</p>\n"}, {"fullname": "fpex0.CP", "modulename": "fpex0.CP", "type": "module", "doc": "<p></p>\n"}, {"fullname": "fpex0.CP.HeatCapacity", "modulename": "fpex0.CP", "qualname": "HeatCapacity", "type": "class", "doc": "<p>Stores cp, usually calculated by fpex0.CP.addCP().</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>T</strong>: Temperatures</p>\n\n<p><strong>values</strong>: Corresponding heat capacities</p>\n\n<p><strong>fun</strong>: Interpolant (of T, values) (function handle).</p>\n\n<p><strong>latentdata</strong>\n<br> Values with subtracted baseline.</p>\n\n<p><strong>latentfun</strong> \n<br> Interpolant of latentdata as (function handle).</p>\n"}, {"fullname": "fpex0.CP.HeatCapacity.__init__", "modulename": "fpex0.CP", "qualname": "HeatCapacity.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">T</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">values</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">fun</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">latentdata</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">latentfun</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "fpex0.CP.CP_DIN11357", "modulename": "fpex0.CP", "qualname": "CP_DIN11357", "type": "function", "doc": "<p>Calculates the (apparent) specific heat capacity.</p>\n\n<p>It applies the \"heat flow calibration\" method: A known reference cp (of sapphire) \nis rescaled using the mass-ratio and signal ratio of reference and sample.</p>\n\n<blockquote>\n<pre><code>cpS(T) = cpR(T) * mR/mS * (dscS(T)-dsc0(T)) / (dscR(T)-dsc0(T))\n</code></pre>\n</blockquote>\n\n<h3 id=\"reference\">Reference</h3>\n\n<p>DIN EN ISO 11357-4:2014 <br>\nPlastics - Differential scanning calorimetry <br>\nDetermination of specific heat capacity</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>T</strong>: Vector of temperatures to evaluate the cp-value</p>\n\n<p><strong>mS</strong>: Mass of sample</p>\n\n<p><strong>dscS</strong>: DSC signal of sample (microvolts)</p>\n\n<p><strong>cpR</strong>: cp-values of reference (cf. fpex0.CP_sapphire_DIN11357())</p>\n\n<p><strong>mR</strong>: Mass of reference</p>\n\n<p><strong>dscR</strong>: DSC signal of reference (microvolts)</p>\n\n<p><strong>dsc0</strong>: DSC signal with two empty crucibles</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>cpS</strong>: cp-values of sample at specified temperatures.</p>\n\n<h3 id=\"comments\">Comments</h3>\n\n<ul>\n<li>If vectors are given, they must coincide in size and meaning, <br>\ni.e.  dscS[k], dscR[k], dsc0[k], cpR[k] all correspond to temperature T[k]</li>\n<li>If dscS and dscR are already baseline-corrected, set dsc0 to 0</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">mS</span>, </span><span class=\"param\"><span class=\"n\">dscS</span>, </span><span class=\"param\"><span class=\"n\">cpR</span>, </span><span class=\"param\"><span class=\"n\">mR</span>, </span><span class=\"param\"><span class=\"n\">dscR</span>, </span><span class=\"param\"><span class=\"n\">dsc0</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.CP.addCP", "modulename": "fpex0.CP", "qualname": "addCP", "type": "function", "doc": "<p>Adds cp values to DSC data structure (setup.DSC_Data).\nCalculation of cp is done with CP_DIN11357.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>DSCsample</strong> \n<br> fpex0.setup.DSC_Data object or list of objects, sample - (e.g. pcm)</p>\n\n<p><strong>DSCreference</strong>\n<br> fpex0.setup.DSC_Data object, reference (e.g. saphire)</p>\n\n<p><strong>DSC0</strong> \n<br> DSC signal with two empty crucibles.                 [default: 0]\n<br> Only needed if signals are not zero-corrected yet.</p>\n\n<p><strong>Tmin</strong>\n<br> Lower temperature bound.                             [default:  55 degC]</p>\n\n<p><strong>Tmax</strong>\n<br> Upper temperature bound.                             [default: 160 degC]</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>DSCsample</strong>\n<br> fpex0.setup.DSC_Data object or list of objects with additional field cp.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">DSCsample</span>, </span><span class=\"param\"><span class=\"n\">DSCreference</span>, </span><span class=\"param\"><span class=\"n\">DSC0</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">Tmin</span><span class=\"o\">=</span><span class=\"mi\">55</span>, </span><span class=\"param\"><span class=\"n\">Tmax</span><span class=\"o\">=</span><span class=\"mi\">160</span>, </span><span class=\"param\"><span class=\"n\">bltype</span><span class=\"o\">=</span><span class=\"s1\">&#39;linear&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.CP.CP_sapphire_DIN11357", "modulename": "fpex0.CP", "qualname": "CP_sapphire_DIN11357", "type": "function", "doc": "<p>Delivers specific heat capacity of saphire for specified temperature according to DIN EN ISO 11357-4:2014-10.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>T</strong>: Temperature <br>\n<strong>unit</strong>: one of \"degC\" or \"K\"    [default: degC]</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>cp</strong>\n<br> Literature value of sapphire as functor.</p>\n\n<p>[!] <em>Note</em>: This approximation is only valid in the interval 100K &lt; T &lt; 1200K.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">unit</span><span class=\"o\">=</span><span class=\"s1\">&#39;degC&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.InitialDistribution", "modulename": "fpex0.InitialDistribution", "type": "module", "doc": "<p></p>\n"}, {"fullname": "fpex0.InitialDistribution.InitialDistribution", "modulename": "fpex0.InitialDistribution", "qualname": "InitialDistribution", "type": "class", "doc": "<p>Class holding initial distribution.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>functionExpressionList</strong> : list\n<br> list of piecewise function definitions</p>\n\n<p><strong>supportList</strong> : list of (tuples or functions)\n<br> List of (open) support intervals, use numpy.inf and -numpy.inf for positive/negative infinity\nif a function is given, it will be evaluated with current parameters and must return a tuple for the support.</p>\n\n<p><strong>psymbols</strong> : tuple of sympy symbols\n<br> Tuple of parameter set (used in all support intervals).</p>\n\n<p><strong>xsymbol</strong> : sympy symbol\n<br> Symbol used as x variable (default: x).</p>\n\n<p><strong>name</strong> : str\n<br> A handy name for the distribution.</p>\n"}, {"fullname": "fpex0.InitialDistribution.InitialDistribution.__init__", "modulename": "fpex0.InitialDistribution", "qualname": "InitialDistribution.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">funcExprList</span>, </span><span class=\"param\"><span class=\"n\">supportList</span>, </span><span class=\"param\"><span class=\"n\">psymbols</span>, </span><span class=\"param\"><span class=\"n\">xsymbol</span><span class=\"o\">=</span><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;unnamed&#39;</span></span>)</span>"}, {"fullname": "fpex0.InitialDistribution.InitialDistribution.getValuesWithinInterval", "modulename": "fpex0.InitialDistribution", "qualname": "InitialDistribution.getValuesWithinInterval", "type": "function", "doc": "<p>Returns values and indices of numpy array x that are inside given interval.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">interval</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.InitialDistribution.InitialDistribution.evalSupport", "modulename": "fpex0.InitialDistribution", "qualname": "InitialDistribution.evalSupport", "type": "function", "doc": "<p>Evaluates support functions at given parameter vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">support</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.InitialDistribution.InitialDistribution.sympy2numpyXP", "modulename": "fpex0.InitialDistribution", "qualname": "InitialDistribution.sympy2numpyXP", "type": "function", "doc": "<p>Lambdify specified function as a function of x and p.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fun</span>, </span><span class=\"param\"><span class=\"n\">xsymbol</span>, </span><span class=\"param\"><span class=\"n\">psymbols</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.InitialDistribution.InitialDistribution.sympy2numpyP", "modulename": "fpex0.InitialDistribution", "qualname": "InitialDistribution.sympy2numpyP", "type": "function", "doc": "<p>Lambdify specified function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fun</span>, </span><span class=\"param\"><span class=\"n\">symbols</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.InitialDistribution.InitialDistribution.functionalizeSupportDescriptor", "modulename": "fpex0.InitialDistribution", "qualname": "InitialDistribution.functionalizeSupportDescriptor", "type": "function", "doc": "<p>Transforms a support descriptor into a callable function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">thing</span>, </span><span class=\"param\"><span class=\"n\">symbols</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.InitialDistribution.InitialDistribution.f", "modulename": "fpex0.InitialDistribution", "qualname": "InitialDistribution.f", "type": "function", "doc": "<p>Evaluates nominal function at x with parameter vector p.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>x</strong>: numpy vector <br>\n<strong>p</strong>: numpy vector</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p><strong>f</strong>: numpy vector</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.InitialDistribution.InitialDistribution.dfdp", "modulename": "fpex0.InitialDistribution", "qualname": "InitialDistribution.dfdp", "type": "function", "doc": "<p>Evaluates jacobian at x with parameter vector p.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>x</strong>: numpy vector <br> \n<strong>p</strong>: numpy vector</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>J</strong>: Numpy matrix dfdp, J[i][...] contains sensitivity w.r.t. p[i].</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.baseline", "modulename": "fpex0.baseline", "type": "module", "doc": "<p></p>\n"}, {"fullname": "fpex0.baseline.BaselineData", "modulename": "fpex0.baseline", "qualname": "BaselineData", "type": "class", "doc": "<p>Stores information about the baselevel.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>reg_L</strong>\n<br> Left linear part.</p>\n\n<p><strong>reg_R</strong>\n<br> Right linear part.</p>\n\n<p><strong>onset</strong> \n<br> Onset of phase transition.</p>\n\n<p><strong>endset</strong>\n<br> Endset of the phase transition.</p>\n"}, {"fullname": "fpex0.baseline.BaselineData.__init__", "modulename": "fpex0.baseline", "qualname": "BaselineData.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">reg_L</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">reg_R</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">onset</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">endset</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "fpex0.baseline.BaselineDetectionSettings", "modulename": "fpex0.baseline", "qualname": "BaselineDetectionSettings", "type": "class", "doc": "<p>Stores (default) baseline detection settings to be passed to <code>fpex0.baseline.detectLinearRange()</code>.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>Naming: </p>\n\n<ul>\n<li>R,L = right or left</li>\n<li>abs, rel = absolute or relative</li>\n<li>dev = deviation</li>\n<li>initfraction = initial fraction of data to interpolate.</li>\n</ul>\n\n<p><strong>LabsdevA</strong>, <strong>LabsdevB</strong>, <strong>LabsdevS2</strong></p>\n\n<p><strong>LreldevA</strong>, <strong>LreldevB</strong>, <strong>LreldevS2</strong></p>\n\n<p><strong>Linitfraction</strong></p>\n\n<p><strong>RabsdevA</strong>, <strong>RabsdevB</strong>, <strong>RabsdevS2</strong></p>\n\n<p><strong>RreldevA</strong>, <strong>RreldevB</strong>, <strong>RreldevS2</strong></p>\n\n<p><strong>Rinitfraction</strong></p>\n"}, {"fullname": "fpex0.baseline.BaselineDetectionSettings.__init__", "modulename": "fpex0.baseline", "qualname": "BaselineDetectionSettings.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "fpex0.baseline.detectLinearRange", "modulename": "fpex0.baseline", "qualname": "detectLinearRange", "type": "function", "doc": "<p>Detect the stop position of the linear range.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>X</strong>: x-values</p>\n\n<p><strong>Y</strong>: y-values</p>\n\n<p><strong>side</strong>: 'L' or 'R' for \"from left\" or \"from right\"</p>\n\n<p><strong>initlen</strong>\n<br> Length (in samples) to calculate the initial standard deviation.</p>\n\n<p><strong>reldevA</strong> \n<br> Acceptable relative deviation of initial y-axis intercept.</p>\n\n<p><strong>reldevB</strong>\n<br> Acceptable relative deviation of initial slope.</p>\n\n<p><strong>reldevS2</strong>\n<br> Acceptable relative deviation of initial squared standard deviation.</p>\n\n<p><strong>absdevA</strong>\n<br> Acceptable absolute deviation of initial y-axis intercept.</p>\n\n<p><strong>absdevB</strong>\n<br> Acceptable absolute deviation of initial.</p>\n\n<p><strong>absdevS2</strong>\n<br> Acceptable absolute deviation of initial squared standard deviation.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>stopidx</strong> \n<br> Position in X, where the linear range is estimated to be left.</p>\n\n<p><strong>reg</strong>\n<br> Final regression structure as returned by fpex0.linreg.LinearRegression.linReg.</p>\n\n<p><strong>initreg</strong>\n<br> Initial regression structure as returned by fpex0.linreg.LinearRegression.linReg.</p>\n\n<h3 id=\"comments\">Comments</h3>\n\n<ul>\n<li><p>Set the <code>reldev</code> to inf to disable</p></li>\n<li><p>Set the <code>absdev</code> to  -1 to disable</p></li>\n<li><p>The <code>reldev</code> is only be checked if value exceeds <code>absdev</code></p></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span>,</span><span class=\"param\">\t<span class=\"n\">Y</span>,</span><span class=\"param\">\t<span class=\"n\">side</span>,</span><span class=\"param\">\t<span class=\"n\">initlen</span>,</span><span class=\"param\">\t<span class=\"n\">reldevAmax</span>,</span><span class=\"param\">\t<span class=\"n\">reldevBmax</span>,</span><span class=\"param\">\t<span class=\"n\">reldevS2max</span>,</span><span class=\"param\">\t<span class=\"n\">absdevAmax</span>,</span><span class=\"param\">\t<span class=\"n\">absdevBmax</span>,</span><span class=\"param\">\t<span class=\"n\">absdevS2max</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.baseline.getBaselinePrimitive", "modulename": "fpex0.baseline", "qualname": "getBaselinePrimitive", "type": "function", "doc": "<p>Retrieves the baselevel function for specified data.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>X</strong>: x-values (temperatures, time, ...)</p>\n\n<p><strong>Y</strong>: y-values (voltage, heat flux, ....)</p>\n\n<p><strong>index_l</strong>\n<br> Index where left linear part is left (\"onset\")</p>\n\n<p><strong>icept_l</strong>\n<br> y-intercept of left linear part.</p>\n\n<p><strong>slope_l</strong>\n<br> Slope of left linear part.</p>\n\n<p><strong>index_r</strong>\n<br> Index where right linear part is left (\"onset\").</p>\n\n<p><strong>icept_r</strong>\n<br> y-intercept of right linear part.</p>\n\n<p><strong>slope_r</strong> \n<br> Slope of right linear part.</p>\n\n<p><strong>bl_type</strong> \n<br> What type should the baselevel function have? \"linear\" or \"sigmoidal\".</p>\n\n<p><strong>res</strong>\n<br> Number of support points for sigmoidal (default: 100).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>blfun</strong>\n<br> Function handle of baselevel function</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span>,</span><span class=\"param\">\t<span class=\"n\">Y</span>,</span><span class=\"param\">\t<span class=\"n\">index_l</span>,</span><span class=\"param\">\t<span class=\"n\">icept_l</span>,</span><span class=\"param\">\t<span class=\"n\">slope_l</span>,</span><span class=\"param\">\t<span class=\"n\">index_r</span>,</span><span class=\"param\">\t<span class=\"n\">icept_r</span>,</span><span class=\"param\">\t<span class=\"n\">slope_r</span>,</span><span class=\"param\">\t<span class=\"n\">bl_type</span>,</span><span class=\"param\">\t<span class=\"n\">res</span><span class=\"o\">=</span><span class=\"mi\">1000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.baseline.getBaseline", "modulename": "fpex0.baseline", "qualname": "getBaseline", "type": "function", "doc": "<p>Retrieves the baselevel function for specified DSC data.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>X</strong>: \n<br> Numpy vector of x-values (e.g. temperatures) or list (!) of vectors.</p>\n\n<p><strong>Y</strong>: \n<br> Numpy vector of y-values (e.g. cp-values) or list (!) of vectors.</p>\n\n<p><strong>bl_type</strong>: 'linear' or 'sigmoidal'\n(default: 'linear')</p>\n\n<p><strong>blds</strong> \n<br> BaselineDetectionSettings-object containing the BaseLine Detection Setting\n(default: Default BLDS object).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>blfun</strong>\n<br> Function handle of baselevel function.</p>\n\n<p><strong>bldata</strong>\n<br> Structure containing information about the baseline.</p>\n\n<p>OR if list have been passed:</p>\n\n<p><strong>baseline_list</strong>:\n<br> List of tuples (blfun, bldata).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span>,</span><span class=\"param\">\t<span class=\"n\">Y</span>,</span><span class=\"param\">\t<span class=\"n\">bl_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;linear&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">blds</span><span class=\"o\">=&lt;</span><span class=\"n\">fpex0</span><span class=\"o\">.</span><span class=\"n\">baseline</span><span class=\"o\">.</span><span class=\"n\">BaselineDetectionSettings</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.baseline.subtractBaseline", "modulename": "fpex0.baseline", "qualname": "subtractBaseline", "type": "function", "doc": "<p>Subtracts the baseline from given points.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>X</strong>: x values (e.g. vector temperatures)</p>\n\n<p><strong>Y</strong>: y values or function (e.g. vector of cp values, or function cp(T))</p>\n\n<p><strong>blfun</strong>\n<br> Function handle to baseline function.</p>\n\n<p><strong>clearzero</strong>\n<br> Flag indicating to clear zeros (see DSC204_clearZeroFromMax) (default: True).</p>\n\n<p><strong>nonnegative</strong>\n<br> Flag indicating to ensure nonnegativity                      (default: True).</p>\n\n<p><strong>onset</strong>\n<br> Onset value (zero values are put below/left of this x value) [optional].</p>\n\n<p><strong>endset</strong>\n<br> Endset value (zero values are put above/right of this x value) [optional].</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>Yvals</strong> \n<br> Processed y values.</p>\n\n<p><strong>Yfun</strong>\n<br> Interpolator of processed values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span>,</span><span class=\"param\">\t<span class=\"n\">Yin</span>,</span><span class=\"param\">\t<span class=\"n\">blfun</span>,</span><span class=\"param\">\t<span class=\"n\">onset</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">endset</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">clearzero</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">nonnegative</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.baseline.clearZeroFromMax", "modulename": "fpex0.baseline", "qualname": "clearZeroFromMax", "type": "function", "doc": "<p>Locates the maximum value in datavec, searches the first occurances\nof a zero value to the left and to the right from the peak position\nand deletes the noise before and after these positions.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>data</strong>: Data array to be cleared</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>data</strong>: Cleared data array</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.example", "modulename": "fpex0.example", "type": "module", "doc": "<p></p>\n"}, {"fullname": "fpex0.example.exampleFit", "modulename": "fpex0.example.exampleFit", "type": "module", "doc": "<p></p>\n"}, {"fullname": "fpex0.example.exampleFit.exampleFit", "modulename": "fpex0.example.exampleFit", "qualname": "exampleFit", "type": "function", "doc": "<p>Runs an example fit with:</p>\n\n<ul>\n<li>An example fpex0 setup configuration, retrieved by <code>fpex0.example.exampleSetup.exampleSetup()</code> (check for details)</li>\n<li>Example data, contained in the fpex0/example/ID407-rate_*.json files</li>\n<li>A Fraser-Suzuki initial distribution</li>\n<li>The scipy solve_ivp BDF integrator to solve the Fokker Planck equation</li>\n<li>The scipy least_squares optimizer to fit the example measurements</li>\n</ul>\n\n<p><br>\nNo in- or output. Prints information and a solution parameter vector. <br></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.example.exampleSetup", "modulename": "fpex0.example.exampleSetup", "type": "module", "doc": "<p></p>\n"}, {"fullname": "fpex0.example.exampleSetup.exampleSetup", "modulename": "fpex0.example.exampleSetup", "qualname": "exampleSetup", "type": "function", "doc": "<p>Generates example setup for FPEX0.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p>No input.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>setup</strong> \n<br> An FPEX0 setup configuration (<code>fpex0.setup.Setup</code>) example.\n<br></p>\n\n<h3 id=\"comments\">Comments</h3>\n\n<p>Diffusion and drift (their value) is connected to the grid step size! <br>\nNOTE: So simulations and fits should be done with identical gridT.</p>\n\n<p>Initial and final diffusion are described by parameters! <br />\n--> Linear diffusion plus condition of a non-negative diffusion at end time</p>\n\n<p>Formula: </p>\n\n<blockquote>\n<pre><code>  Diffusion = pD1 + t*(pD2-pD1)/betamax\n</code></pre>\n</blockquote>\n\n<p>where</p>\n\n<blockquote>\n<pre><code>  betamax --&gt; maximum heat rate (maximum time in FP) ,\n  pD1     --&gt; initial diffusion at heat rate (time) 0\n  pD2     --&gt; final diffusion at heat rate (time) betamax\n</code></pre>\n</blockquote>\n\n<p>NOTE:  Parameter bounds\nParameter bounds should never be active in the solution. </p>\n\n<p>Their only role is to limit search space and to ensure that no \"invalid\" valued are attained.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.example.exampleSetup.importExampleMeasurements", "modulename": "fpex0.example.exampleSetup", "qualname": "importExampleMeasurements", "type": "function", "doc": "<p>Imports example measurement into a given setup FPEX0setup.\n<br></p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>FPEX0setup</strong>\n<br> An FPEX0 setup configuration (<code>fpex0.setup.Setup</code>).</p>\n\n<p><strong>gridskip</strong>\n<br> Use grid with given stepsize (gridskip). \n<br> For gridskip=2 for example, only every second grid point is used,\nwhereas gridskip=1 uses whole grid.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>FPEX0setup</strong>\n<br> The FPEX0setup passed in, now having imported example measurements in parameter FPEX0setup.Measurements.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">FPEX0setup</span>, </span><span class=\"param\"><span class=\"n\">gridskip</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.fokker_planck", "modulename": "fpex0.fokker_planck", "type": "module", "doc": "<p></p>\n"}, {"fullname": "fpex0.fokker_planck.FokkerPlanck", "modulename": "fpex0.fokker_planck", "qualname": "FokkerPlanck", "type": "class", "doc": "<p></p>\n"}, {"fullname": "fpex0.fokker_planck.FokkerPlanck.__init__", "modulename": "fpex0.fokker_planck", "qualname": "FokkerPlanck.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "fpex0.fokker_planck.FokkerPlanck.FokkerPlanckODE", "modulename": "fpex0.fokker_planck", "qualname": "FokkerPlanck.FokkerPlanckODE", "type": "function", "doc": "<p>ODE RHS of Fokker-Planck PDE by using the method of lines (MOL) approach.</p>\n\n<p>FP-PDE</p>\n\n<blockquote>\n<pre><code>  u_t = - a(t,p) * u_x(t,x)  +  D(t,p) * u_xx(t,x)\n</code></pre>\n</blockquote>\n\n<p>FD-Approx</p>\n\n<blockquote>\n<pre><code>  u_x  = ( u(t,x+h) - u(t,x-h ) / (2h)\n  u_xx = ( u(t,x+h) - 2u(t,x) + u(t,x-h) ) / h\n</code></pre>\n</blockquote>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>t</strong>: Time</p>\n\n<p><strong>x</strong>: State vector</p>\n\n<p><strong>h</strong>: MOL interval size</p>\n\n<p><strong>driftFcn</strong>\n<br> Drift function, evaluated at t, driftP.</p>\n\n<p><strong>driftParams</strong>\n<br> Parameter vector for drift function.</p>\n\n<p><strong>diffusionFcn</strong>\n<br> Diffusion function, evaluated at t, driftP.</p>\n\n<p><strong>diffusionParams</strong>\n<br> Parameter vector for diffusion function.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>dx</strong>\n<br> rhs vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">driftFcn</span>, </span><span class=\"param\"><span class=\"n\">driftParams</span>, </span><span class=\"param\"><span class=\"n\">diffusionFcn</span>, </span><span class=\"param\"><span class=\"n\">diffusionParams</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.fokker_planck.FokkerPlanck.FokkerPlanckODE_dfdu", "modulename": "fpex0.fokker_planck", "qualname": "FokkerPlanck.FokkerPlanckODE_dfdu", "type": "function", "doc": "<p>Jacobian of FokkerPlanckODE w.r.t. state u, i.e. df/du. </p>\n\n<p>FP-PDE</p>\n\n<blockquote>\n<pre><code>  u_t = - a(t,p) * u_x(t,x)  +  D(t,p) * u_xx(t,x)\n\n  where a is the driftFcn, and b is the diffusionFcn\n</code></pre>\n</blockquote>\n\n<p>FD-Approx  </p>\n\n<blockquote>\n<pre><code>  u_x  = ( u(t,x+h) - u(t,x-h ) / (2h)\n  u_xx = ( u(t,x+h) - 2u(t,x) + u(t,x-h) ) / h\n</code></pre>\n</blockquote>\n\n<p>Jacobian</p>\n\n<blockquote>\n<pre><code>  df/du = -a(t,p) * A + D(t,p) * B\n\n  where A is the first-derivative stencil [-1 0 1]\n  and B is the second-derivative stencil [1 -2 1] plus Robin boundary\n</code></pre>\n</blockquote>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>t</strong>: Time</p>\n\n<p><strong>x</strong>: State vector</p>\n\n<p><strong>h</strong>: MOL interval size</p>\n\n<p><strong>driftFcn</strong>\n<br> Drift function, evaluated at t, driftP.</p>\n\n<p><strong>driftParams</strong>\n<br> Parameter vector for drift function.</p>\n\n<p><strong>diffusionFcn</strong>\n<br> Diffusion function, evaluated at t, driftP.</p>\n\n<p><strong>diffusionParams</strong>\n<br> Parameter vector for diffusion function.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>dfdu</strong>\n<br> Sparse jacobian of FokkerPlanckODE (scipy.sparse).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">u</span>, </span><span class=\"param\"><span class=\"n\">h</span>, </span><span class=\"param\"><span class=\"n\">driftFcn</span>, </span><span class=\"param\"><span class=\"n\">driftParams</span>, </span><span class=\"param\"><span class=\"n\">diffusionFcn</span>, </span><span class=\"param\"><span class=\"n\">diffusionParams</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.fokker_planck.FokkerPlanck.defaultDriftFcn", "modulename": "fpex0.fokker_planck", "qualname": "FokkerPlanck.defaultDriftFcn", "type": "function", "doc": "<p>Default drift function used in FPEX0.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>t</strong>\n<br> Current time / heating rate.</p>\n\n<p><strong>p</strong>\n<br> Drift parameter vector (drift-parameters only!).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>fval</strong>\n<br> Function value for drift.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">p</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.fokker_planck.FokkerPlanck.defaultDiffusionFcn", "modulename": "fpex0.fokker_planck", "qualname": "FokkerPlanck.defaultDiffusionFcn", "type": "function", "doc": "<p>Default diffusion function used in FPEX0.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>t</strong>\n<br> Current time / heating rate.</p>\n\n<p><strong>p</strong>\n<br> Diffusion parameter vector (diffusion-parameters only!).</p>\n\n<p><strong>betamax</strong>\n<br> Maximum time / heat rate (used for ensuring non-negativity).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>fval</strong>\n<br> Function value for diffusion.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">betamax</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.fpex0", "modulename": "fpex0.fpex0", "type": "module", "doc": "<p></p>\n"}, {"fullname": "fpex0.fpex0.simulate", "modulename": "fpex0.fpex0", "qualname": "simulate", "type": "function", "doc": "<p>Simulates Fokker-Planck with specified parameters for FP drift, diffusion, and initial function.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>FPEX0setup</strong>\n<br> An FPEX0 setup configuration (<code>fpex0.setup.Setup</code>).</p>\n\n<p><strong>p_all</strong>\n<br> Vector of parameters, coupled to FPEX0setup.\n<br> It must have the same scheme as FPEX0setup.Parameters.p_0, \nthen simulate() knows how to extract the parameters correctly.\nUsually this is ensured by the optimizer, who got the initial parameters and changes them through\noptimization steps.</p>\n\n<p><strong>odeoptions</strong>\n<br> kwargs passed to the scipy solve_ivp ODE solver \n(https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html). </p>\n\n<p><strong>method</strong>\n<br> The method scipy solve_ivp should use.\n<br> Default is BDF, an an implicit multistep method.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>solution</strong>\n<br> A scipy solve_ivp bunch object. Important parameters are</p>\n\n<ul>\n<li>t: time points</li>\n<li>y: corresponding values</li>\n<li>sol: A (here) callable solution</li>\n</ul>\n\n<p>See link above for details.</p>\n\n<h3 id=\"comments\">Comments</h3>\n\n<p>The function will not let you set dense_output = False in odeoptions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">FPEX0setup</span>, </span><span class=\"param\"><span class=\"n\">pvec</span>, </span><span class=\"param\"><span class=\"n\">odeoptions</span><span class=\"o\">=</span><span class=\"p\">{}</span>, </span><span class=\"param\"><span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;BDF&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.fpex0.fit", "modulename": "fpex0.fpex0", "qualname": "fit", "type": "function", "doc": "<p>Fits the Fokker-Planck simulation to the given measurements as an optimization of the parameters\nfor drift, diffusion and the initial distribution.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>FPEX0setup</strong>\n<br> An FPEX0 setup configuration (<code>fpex0.setup.Setup</code>).</p>\n\n<p><strong>optimizer</strong>\n<br> The optimizer that should be used. So far only least squares is implemented.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>result</strong> \n<br> The optimized parameters as a vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">FPEX0setup</span>, </span><span class=\"param\"><span class=\"n\">optimizer</span><span class=\"o\">=</span><span class=\"s1\">&#39;lsq&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.fpex0.residual", "modulename": "fpex0.fpex0", "qualname": "residual", "type": "function", "doc": "<p>Calculates the residual vector of measurements and simulation values, i.e. measVals - simVals\nat suitable points.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>FPEX0setup</strong>\n<br> An FPEX0 setup configuration (<code>fpex0.setup.Setup</code>).</p>\n\n<p><strong>p_all</strong>\n<br> Vector of parameters, coupled to FPEX0setup.\n<br> It must have the same scheme as FPEX0setup.Parameters.p_0, \nthen residual() knows how to use the parameters correctly.\nUsually this is ensured by the optimizer, who got the initial parameters and changes them through\noptimization steps.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p><strong>resvec</strong>\n<br> Residual vector as described above.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">FPEX0setup</span>, </span><span class=\"param\"><span class=\"n\">p_all</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.linreg", "modulename": "fpex0.linreg", "type": "module", "doc": "<p></p>\n"}, {"fullname": "fpex0.linreg.LinearRegression", "modulename": "fpex0.linreg", "qualname": "LinearRegression", "type": "class", "doc": "<p>Assumes a linear model:  Yi = a + b*Xi + ei    with ei ~ N(0,s^2)\nand calculates the simple linear regression according to [1].</p>\n\n<p>Executes regression and holds regression parameters. \n<br> If a first regression has been made, any following execution of self.linReg(X, Y) will update the\nregression with the additional point (X, Y).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>Regression represented by following fields:\n<strong>a</strong> Estimate for a</p>\n\n<p><strong>b</strong>: Estimate for b</p>\n\n<p><strong>s2</strong>: Estimate for s^2</p>\n\n<p><strong>Xmean</strong>: Mean value of Xi</p>\n\n<p><strong>Ymean</strong>: mean value of Yi</p>\n\n<p><strong>Sxx</strong>: S_X^2</p>\n\n<p><strong>Sxy</strong>: S_XY</p>\n\n<p><strong>Syy</strong>: S_Y^2</p>\n\n<p><strong>See</strong>: S_e^2</p>\n\n<h3 id=\"sources\">Sources</h3>\n\n<p>[1] Jerome H. Klotz: \"Updating Simple Linear Regression\", 1995. <br>\n[2] Statistica Sinica 5 (1995), 399-403.</p>\n"}, {"fullname": "fpex0.linreg.LinearRegression.__init__", "modulename": "fpex0.linreg", "qualname": "LinearRegression.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "fpex0.linreg.LinearRegression.linReg", "modulename": "fpex0.linreg", "qualname": "LinearRegression.linReg", "type": "function", "doc": "<p>Sets or updates the regression attributes.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>X</strong>: numpy.array or number <br>\n<strong>Y</strong>: numpy.array or number</p>\n\n<p>X, Y must be either both arrays or both numbers.</p>\n\n<h3 id=\"note\">Note</h3>\n\n<p>A vector update has not yet been implemented, but is planned.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">Y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup", "modulename": "fpex0.setup", "type": "module", "doc": "<p></p>\n"}, {"fullname": "fpex0.setup.DSC_Data", "modulename": "fpex0.setup", "qualname": "DSC_Data", "type": "class", "doc": "<p>Class for dsc data. Stores unprocessed and processed data.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>mass</strong>\n<br> Sample mass.</p>\n\n<p><strong>rate</strong>\n<br> Heating rate.</p>\n\n<p><strong>T</strong>\n<br> Temperatures.</p>\n\n<p><strong>dsc</strong>\n<br> Corresponding raw DSC measurements.</p>\n\n<p><strong>bldata</strong> \n<br> Information about the baselevel.</p>\n\n<p><strong>blfun</strong> \n<br> Baselevel function as retrieved by <code>fpex0.baseline.getBaseline</code>.</p>\n\n<p><strong>cp</strong> \n<br> Calculated heat capacities as HeatCapacitiy member.</p>\n\n<p><strong>ID</strong>\n<br> Name/identifier of experiment.</p>\n"}, {"fullname": "fpex0.setup.DSC_Data.__init__", "modulename": "fpex0.setup", "qualname": "DSC_Data.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">T</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dsc</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">mass</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">rate</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bldata</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">blfun</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cp</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "fpex0.setup.Setup", "modulename": "fpex0.setup", "qualname": "Setup", "type": "class", "doc": "<p>FPEX0 configuration.</p>\n\n<h2 id=\"parameters-fpex0setupgrid\">Parameters : <code>fpex0.setup.Grid</code></h2>\n\n<p><strong>Grid</strong>\n<br> A discretization grid for Fokker-Planck.</p>\n\n<p><strong>Parameters</strong>\n<br> A collection of parameters and boudns, \ninstance of <code>fpex0.setup.Parameters</code>.</p>\n\n<p><strong>Integration</strong> : <code>fpex0.setup.Integration</code>\n<br> Represents an integrator to solve our discretization of Fokker-Planck.</p>\n\n<p><strong>FPdriftFcn</strong> \n<br> Function object of Fokker-Planck drift.</p>\n\n<p><strong>FPdiffusionFcn</strong>\n<br> Function object of Fokker-Planck diffusion.</p>\n\n<p><strong>IniDistFcn</strong>\n<br> Function object of inital distribution.</p>\n"}, {"fullname": "fpex0.setup.Setup.__init__", "modulename": "fpex0.setup", "qualname": "Setup.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">Grid</span>,</span><span class=\"param\">\t<span class=\"n\">Parameters</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">Integration</span>,</span><span class=\"param\">\t<span class=\"n\">FPdriftFcn</span>,</span><span class=\"param\">\t<span class=\"n\">FPdiffusionFcn</span>,</span><span class=\"param\">\t<span class=\"n\">IniDistFcn</span></span>)</span>"}, {"fullname": "fpex0.setup.Setup.make_rhsFcn", "modulename": "fpex0.setup", "qualname": "Setup.make_rhsFcn", "type": "function", "doc": "<p>Generator for the ODEs right-hand-side.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">p_FPdrift</span>, </span><span class=\"param\"><span class=\"n\">p_FPdiffusion</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Setup.make_jacFcn", "modulename": "fpex0.setup", "qualname": "Setup.make_jacFcn", "type": "function", "doc": "<p>Generator for the ODEs jacobian.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">p_FPdrift</span>, </span><span class=\"param\"><span class=\"n\">p_FPdiffusion</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Setup.importMeasurements", "modulename": "fpex0.setup", "qualname": "Setup.importMeasurements", "type": "function", "doc": "<p>Imports measurements into FPEX0setup (<code>fpex0.setup.Measurements</code>).\nAn interpolation to the integration grid is performed and the interpolated values are stored.</p>\n\n<h2 id=\"takes\">Takes</h2>\n\n<p><strong>FPEX0setup</strong>\n<br> FPEX0_class_setup object.</p>\n\n<p><strong>ID</strong> \n<br> Name/identifier of experiment.</p>\n\n<p><strong>heatrate</strong>\n<br> Heating rate.</p>\n\n<p><strong>T</strong>\n<br> Temperature grid / measurement positions.</p>\n\n<p><strong>values</strong>\n<br> Measurement values (e.g. cp-values); \nwhere values[k] denotes the measurement value at T[k].</p>\n\n<p><strong>gridskip</strong>\n<br> Use grid with given stepsize (gridskip). \n<br> For gridskip=2 for example, only every second grid point is used,\nwhereas gridskip=1 uses the whole grid.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>No return value.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">values</span>, </span><span class=\"param\"><span class=\"n\">heatrate</span>, </span><span class=\"param\"><span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">gridskip</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Setup.importDSCobject", "modulename": "fpex0.setup", "qualname": "Setup.importDSCobject", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">DSC_Data</span>, </span><span class=\"param\"><span class=\"n\">gridskip</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Parameters", "modulename": "fpex0.setup", "qualname": "Parameters", "type": "class", "doc": "<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>p0</strong>\n<br> Full initial parameter vector.</p>\n\n<p><strong>p_lb</strong>\n<br> Full parameter lower bound vector.</p>\n\n<p><strong>p_ub</strong>\n<br> Full parameter upper bound vector.</p>\n\n<p><strong>p0_FPdrift</strong>\n<br> Initial drift parameter vector.</p>\n\n<p><strong>p0_FPdiffusion</strong>\n<br> Initial diffusion parameter vector.</p>\n\n<p><strong>p0_iniDist</strong>\n<br> Initial paramater vector for initial distribution.</p>\n\n<p><strong>p_lb_FPdrift</strong>\n<br> Lower bound vector for drift parameters.</p>\n\n<p><strong>p_lb_FPdiffusion</strong>\n<br> ...</p>\n\n<p><strong>p_lb_iniDist</strong>\n<br> ...</p>\n\n<p><strong>p_ub_FPdrift</strong>\n<br> Upper bound vector for drift parameters.</p>\n\n<p><strong>p_ub_FPdiffusion</strong>\n<br> ...</p>\n\n<p><strong>p_ub_iniDist</strong>\n<br> ...</p>\n\n<p><strong>idxFPdrift</strong>\n<br> Indices of drift parameters in p0 (resp. p_lb, p_ub).</p>\n\n<p><strong>idxFPdiffusion</strong>\n<br> Same thing, diffusion parameters. </p>\n\n<p><strong>idxFPall</strong>\n<br> Same thing, all Fokker-Planck parameters.</p>\n\n<p><strong>idxIniDist</strong>\n<br> Same thing, initial distribution parameters.</p>\n"}, {"fullname": "fpex0.setup.Parameters.__init__", "modulename": "fpex0.setup", "qualname": "Parameters.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">p0_FPdrift</span>,</span><span class=\"param\">\t<span class=\"n\">p0_FPdiffusion</span>,</span><span class=\"param\">\t<span class=\"n\">p0_iniDist</span>,</span><span class=\"param\">\t<span class=\"n\">p_lb_FPdrift</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">p_lb_FPdiffusion</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">p_lb_iniDist</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">p_ub_FPdrift</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">p_ub_FPdiffusion</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">p_ub_iniDist</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "fpex0.setup.Parameters.extract_p_all", "modulename": "fpex0.setup", "qualname": "Parameters.extract_p_all", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pvec</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Parameters.extract_p_FPdrift", "modulename": "fpex0.setup", "qualname": "Parameters.extract_p_FPdrift", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pvec</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Parameters.extract_p_FPdiffusion", "modulename": "fpex0.setup", "qualname": "Parameters.extract_p_FPdiffusion", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pvec</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Parameters.extract_p_FPall", "modulename": "fpex0.setup", "qualname": "Parameters.extract_p_FPall", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pvec</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Parameters.extract_p_iniDist", "modulename": "fpex0.setup", "qualname": "Parameters.extract_p_iniDist", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">pvec</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Parameters.set_p0", "modulename": "fpex0.setup", "qualname": "Parameters.set_p0", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">p0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Parameters.set_p_lb", "modulename": "fpex0.setup", "qualname": "Parameters.set_p_lb", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">p_lb</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Parameters.set_p_ub", "modulename": "fpex0.setup", "qualname": "Parameters.set_p_ub", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">p_ub</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Grid", "modulename": "fpex0.setup", "qualname": "Grid", "type": "class", "doc": "<p>FPEX0 discretization(?) grid.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>gridT</strong>\n<br> x-grid = temperatures\n<br> This is our method of lines discretization grid.</p>\n\n<p><strong>gridTdot</strong>\n<br> t-grid = heating rates</p>\n\n<p><strong>N</strong> \n<br> Number of grid points.</p>\n\n<p><strong>h</strong> \n<br> Grid size.</p>\n"}, {"fullname": "fpex0.setup.Grid.__init__", "modulename": "fpex0.setup", "qualname": "Grid.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gridT</span>, </span><span class=\"param\"><span class=\"n\">gridTdot</span></span>)</span>"}, {"fullname": "fpex0.setup.Measurements", "modulename": "fpex0.setup", "qualname": "Measurements", "type": "class", "doc": "<p>Stores measurement data in list containers.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>rawT</strong> \n <br> Measurement temperatures.</p>\n\n<p><strong>temperatures</strong> \n <br> Selected temperatures from temperature grid.</p>\n\n<p><strong>rawValues</strong> \n <br> Raw masurement values.</p>\n\n<p><strong>values</strong> \n <br> rawValues interpolated to grid.</p>\n\n<p><strong>rates</strong> \n <br> Heat rates.</p>\n\n<p><strong>ID</strong> \n <br> Experiment name/identifier.</p>\n"}, {"fullname": "fpex0.setup.Measurements.__init__", "modulename": "fpex0.setup", "qualname": "Measurements.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rawT</span><span class=\"o\">=</span><span class=\"p\">[]</span>, </span><span class=\"param\"><span class=\"n\">temperatures</span><span class=\"o\">=</span><span class=\"p\">[]</span>, </span><span class=\"param\"><span class=\"n\">rawValues</span><span class=\"o\">=</span><span class=\"p\">[]</span>, </span><span class=\"param\"><span class=\"n\">values</span><span class=\"o\">=</span><span class=\"p\">[]</span>, </span><span class=\"param\"><span class=\"n\">rates</span><span class=\"o\">=</span><span class=\"p\">[]</span>, </span><span class=\"param\"><span class=\"n\">ID</span><span class=\"o\">=</span><span class=\"p\">[]</span></span>)</span>"}, {"fullname": "fpex0.setup.Measurements.appendMeasurement", "modulename": "fpex0.setup", "qualname": "Measurements.appendMeasurement", "type": "function", "doc": "<p>Appends given measurements to the measurement parameters.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">new_T</span>,</span><span class=\"param\">\t<span class=\"n\">new_temperatures</span>,</span><span class=\"param\">\t<span class=\"n\">new_rawValues</span>,</span><span class=\"param\">\t<span class=\"n\">new_values</span>,</span><span class=\"param\">\t<span class=\"n\">new_rate</span>,</span><span class=\"param\">\t<span class=\"n\">new_ID</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Integration", "modulename": "fpex0.setup", "qualname": "Integration", "type": "class", "doc": "<p>Represents FPEX0 integrator.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><strong>method</strong>\n<br> Method to use by scipy solve_ivp. Default is BDF.</p>\n\n<p><strong>options</strong>\n<br> Integration options. Currently not used. </p>\n\n<p><strong>integrator</strong>\n<br> Integrator for ODEs. Should have the signature integrator(FPrhs, t0tf, u0, method).</p>\n\n<p><strong>NN, A, B</strong>: Internal variables used by FokkerPlanckODE_dfdu.</p>\n"}, {"fullname": "fpex0.setup.Integration.__init__", "modulename": "fpex0.setup", "qualname": "Integration.__init__", "type": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">integrator</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">solve_ivp</span><span class=\"o\">&gt;</span>, </span><span class=\"param\"><span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;BDF&#39;</span>, </span><span class=\"param\"><span class=\"n\">options</span><span class=\"o\">=</span><span class=\"p\">{}</span></span>)</span>"}, {"fullname": "fpex0.setup.Integration.updateOptions", "modulename": "fpex0.setup", "qualname": "Integration.updateOptions", "type": "function", "doc": "<p>Returns the integrators options.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">newOptions</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "fpex0.setup.Integration.updateJacobian", "modulename": "fpex0.setup", "qualname": "Integration.updateJacobian", "type": "function", "doc": "<p>Returns an option dictionary with updated jacobian.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">jacobianFcn</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();