import numpy as np
import pandas as pd
from . import const as const, statistical_significance as statistical_significance
from ._custom_disparity_metric import custom_disparity_metric as custom_disparity_metric
from .types import DifferenceCalculation as DifferenceCalculation, Disparity as Disparity, DisparityCalculation as DisparityCalculation, RatioCalculation as RatioCalculation, ResidualSMDDenominator as ResidualSMDDenominator, SMDDenominator as SMDDenominator, ShortfallMethod as ShortfallMethod, StatSig as StatSig, StatSigHypothesis as StatSigHypothesis, StatSigTest as StatSigTest
from solas_disparity.conditioning import condition as condition
from solas_disparity.utils import pgrg_ordered as pgrg_ordered
from solas_disparity.validation import validation as validation
from typing import Dict, List, Optional, Union

def adverse_impact_ratio(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: pd.Series, air_threshold: float, percent_difference_threshold: float, label: Optional[pd.Series] = ..., sample_weight: Optional[pd.Series] = ..., max_for_fishers: int = ..., alternative_hypothesis: Union[str, StatSigHypothesis] = ..., shortfall_method: Optional[Union[str, ShortfallMethod]] = ...) -> Disparity: ...
def adverse_impact_ratio_by_quantile(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], air_threshold: float, percent_difference_threshold: float, quantiles: Union[pd.Series, np.ndarray, List[float]], label: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., max_for_fishers: int = ..., alternative_hypothesis: Union[str, StatSigHypothesis] = ..., lower_score_favorable: bool = ..., merge_bins: bool = ...) -> Disparity: ...
def categorical_adverse_impact_ratio(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], air_threshold: float, percent_difference_threshold: float, ordinal_categories: Union[pd.Series, np.ndarray, List], label: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., max_for_fishers: int = ..., alternative_hypothesis: Union[str, StatSigHypothesis] = ...) -> Disparity: ...
def odds_ratio(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: pd.Series, odds_ratio_threshold: float, percent_difference_threshold: float, lower_score_favorable: bool = ..., label: Optional[pd.Series] = ..., sample_weight: Optional[pd.Series] = ..., max_for_fishers: int = ..., alternative_hypothesis: Union[str, StatSigHypothesis] = ...) -> Disparity: ...
def standardized_mean_difference(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: pd.Series, smd_threshold: float, lower_score_favorable: bool = ..., label: Optional[pd.Series] = ..., sample_weight: Optional[pd.Series] = ..., smd_denominator: Union[str, SMDDenominator] = ...) -> Disparity: ...
def residual_standardized_mean_difference(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], prediction: Union[pd.Series, np.ndarray, pd.DataFrame], label: Union[pd.Series, np.ndarray, pd.DataFrame], residual_smd_threshold: float, lower_score_favorable: bool = ..., sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., residual_smd_denominator: Optional[Union[str, ResidualSMDDenominator]] = ...): ...
def segmented_adverse_impact_ratio(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], air_threshold: float, percent_difference_threshold: float, fdr_threshold: float, segment: Union[pd.Series, np.ndarray, pd.DataFrame], label: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., max_for_fishers: int = ..., alternative_hypothesis: Union[str, StatSigHypothesis] = ..., shift_zeros: bool = ..., overwrite_segment_results: bool = ...) -> Disparity: ...
def true_positive_rate(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], label: Union[pd.Series, np.ndarray, pd.DataFrame], ratio_threshold: float, difference_threshold: float, sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., statistical_significance_test: Optional[StatSigTest] = ..., statistical_significance_pvalue_threshold: float = ..., statistical_significance_kwargs: Optional[Dict] = ...) -> Disparity: ...
def true_negative_rate(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], label: Union[pd.Series, np.ndarray, pd.DataFrame], ratio_threshold: float, difference_threshold: float, sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., statistical_significance_test: Optional[StatSigTest] = ..., statistical_significance_pvalue_threshold: float = ..., statistical_significance_kwargs: Optional[Dict] = ...) -> Disparity: ...
def positive_predictive_value(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], label: Union[pd.Series, np.ndarray, pd.DataFrame], ratio_threshold: float, difference_threshold: float, sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., statistical_significance_test: Optional[StatSigTest] = ..., statistical_significance_pvalue_threshold: float = ..., statistical_significance_kwargs: Optional[Dict] = ...) -> Disparity: ...
def false_positive_rate(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], label: Union[pd.Series, np.ndarray, pd.DataFrame], ratio_threshold: float, difference_threshold: float, sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., statistical_significance_test: Optional[StatSigTest] = ..., statistical_significance_pvalue_threshold: float = ..., statistical_significance_kwargs: Optional[Dict] = ...) -> Disparity: ...
def false_negative_rate(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], label: Union[pd.Series, np.ndarray, pd.DataFrame], ratio_threshold: float, difference_threshold: float, sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., statistical_significance_test: Optional[StatSigTest] = ..., statistical_significance_pvalue_threshold: float = ..., statistical_significance_kwargs: Optional[Dict] = ...) -> Disparity: ...
def false_discovery_rate(group_data: pd.DataFrame, protected_groups: List[str], reference_groups: List[str], group_categories: List[str], outcome: Union[pd.Series, np.ndarray, pd.DataFrame], label: Union[pd.Series, np.ndarray, pd.DataFrame], ratio_threshold: float, difference_threshold: float, sample_weight: Optional[Union[pd.Series, np.ndarray, pd.DataFrame]] = ..., statistical_significance_test: Optional[StatSigTest] = ..., statistical_significance_pvalue_threshold: float = ..., statistical_significance_kwargs: Optional[Dict] = ...) -> Disparity: ...
